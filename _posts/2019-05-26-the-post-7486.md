---
title: 'SOLID ( 객체지향 설계원칙 )'
layout: post
tags:
  - SOLID
  - SRP
category: 
---
> 이 글은 개발하면서 궁금한 점들을 찾아보면서 내가 이해한 것을 내가 이해하기 쉽게 적은 글 이므로, 비판적인 시각으로 봐주시면 감사하겠습니다.

# SOLID ( 객체 지향 설계 )

'프로그래밍을 할 때 가장 중요한 것이 무엇인가요?' 라고 물어본다면, 2019년 5월 27일의 나로서는 아래와 같이 답할 것이다.

`"유지보수가 쉽고 확장성 있게 짜는거요."`

유지보수가 쉽다는 말은 풀어서 아래를 충족하면 된다고 생각한다. ~~말은 쉽지~~

* 시간이 지나도 이해가 잘 된다.
* 요구사항이 변경/추가될 때 짜증이 안난다.

물론 더 여러가지가 있겠지만 위의 범주안에 어느정도 포함 될 것이고, 위를 만족한다면 어느정도 설계를 잘 했다고 파악된다.
그렇다면 위를 만족시키려면 어떻게 해야할까?
여러가지 지침들이 있지만, 2000대 초반에 나온 개념으로 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙인 SOLID 원칙부터 살펴보고자 한다.

## SRP ( 단일 책임의 원칙 )

먼저 SOLID 의 첫 글자인 S는, Single Responsibility Principle이다. 즉, 하나의 클래스는 하나의 책임만을 가져야한다는 원칙이다.
'너의 행동에 책임을 져라.' 라는 말이 있다. ~~이 말이 왜 나와...??~~
소프트웨어에서의 행위자는 **Actor**다.
즉 우리는 Actor의 행동이 정말 Actor의 책임인지 파악하고, 책임을 분리하여야 한다.

### 책임을 분리하자

어떤 사람이 ATM기계에서 만원을 인출하는 상황을 코드로 작성해보자.

``` swift
person.withdrawal(atm, amount: 10000)
```

인출의 행동의 주체가 person이기 때문에 위와 같은 코드가 순간적으로 그렇구나~ 라고 생각할 수 있다.
하지만 더 논리적으로 볼 필요가 있다. 인출의 책임이 과연 사람에게 있는 것인가?
만약 위의 인출함수를 작성한다면 ~~어떻게 짜야하지...~~ 어떤 카드로 인출할 것 인지, 인출한 돈을 어떻게 할 것인지 함수 내부에서 결정해야한다. 즉 사람에게 책임을 너무 많이 주었다고 볼 수 있다.

생각해보면, 사람은 ATM에 카드를 넣고 인출을 요청하면, ATM이 은행 서버와 통신하여 돈을 인출해주는 것이다.
즉 인출의 책임은 ATM에게 있다는 것을 알 수 있으며, 간단하게 코드로 작성해보면 아래와 같다.

``` swift
let card = // get a card to withdrawal
atm.withdrawal(card, 10000) { money in
	// how to deal
}

```
우리는 사물의 행동을 생각하는 것이 어색할 수 있다. 하지만 단일 책임의 원칙을 곱씹어보면서, 하나의 Actor에 하나의 책임을 주는 연습을 해야한다.

### 조금 더 분리해보자

사실 ATM은 출금뿐만 아니라 입금, 통장정리, 잔액조회, 현금서비스 등 여러가지 기능을 지원해야한다.
이젠 책임이 많아보이지 않는가? 그렇다면 ATM의 책임을 더 명확하게 해보자.

* 다양한 요청을 은행서버에 보낸다.
* 서버에서 받아온 응답값으로 그에 맞는 행동을 한다.

``` swift
let bankRequest = BankRequest(type: .withdrawal(card, 10000))
atm.request(bankRequest) { response
	// to do something
}
```

위 코드를 보면 ATM의 책임이 명확히 보이게 된다. 현재 예를 든 코드에서도 아직 많은 역할들이(카드에 대한 인증, 출력 등) 분리되어야하지만 이 글에선 여기까지 하도록 하겠다. ~~귀찮다~~

### 책임을 적당히 분리하자

'적당히? 갑자기?' 라고 생각할 수 있다.
책임을 분리하여 하나의 Actor가 하나의 책임만 갖도록 하라고 했지, 무작정 책임 작게 쪼개어 분리시키는 것이 좋은 것만은 아니다. 실제 개발시에는 분리를 어디까지 하느냐하는 판단도 중요하다. ATM을 구성하는 MOSFET(반도체 소자)의 책임까지 고려할 것은 아니지 않은가?

그렇다면 우리는 어느 단계까지 책임을 쪼개는 것이 맞을까?

`프로그래밍 변경이 필요한 책임의 최소 단위까지`

만약 더 쪼갠다면, 예를들어 A라는 책임을 a, b, c의 부분 책임으로 열심히 나누었는데 A라는 책임을 변경해야한다면 3개의 클래스를 변경해야하는 상황이 발생하기 때문이다. 사실 이 판단은 경험과 통찰력, 예지력이 필요하지만, 단일 책임 원칙을 지키면서 작성하려고 노력하다보면, 판단력의 수준은 계속해서 높아질 것이다.

## OCP ( 개방 - 폐쇄 원칙 )
## LSP ( 리스코프 치환 원칙 )
## ISP ( 인터페이스 분리 원칙 )
## DIP ( 의존관계 역전 원칙 )