---
title: 'SOLID ( 객체지향 설계원칙 )'
layout: post
tags:
  - SOLID
  - SRP
category: 
---
> 작성중인 글 입니다.

> 이 글은 개발하면서 궁금한 점들을 찾아보면서 내가 이해한 것을 내가 이해하기 쉽게 적은 글 이므로, 비판적인 시각으로 봐주시면 감사하겠습니다.

# SOLID ( 객체 지향 설계 )

'프로그래밍을 할 때 가장 중요한 것이 무엇인가요?' 라고 물어본다면, 2019년 5월 27일의 나로서는 아래와 같이 답할 것이다.

`"유지보수가 쉽고 확장성 있게 짜는거요."`

유지보수가 쉽다는 말은 풀어서 아래를 충족하면 된다고 생각한다. ~~말은 쉽지~~

* 시간이 지나도 이해가 잘 된다.
* 요구사항이 변경/추가될 때 짜증이 안난다.

물론 더 여러가지가 있겠지만 위의 범주안에 어느정도 포함 될 것이고, 위를 만족한다면 어느정도 설계를 잘 했다고 파악된다.
그렇다면 위를 만족시키려면 어떻게 해야할까?
여러가지 지침들이 있지만, 2000대 초반에 나온 개념으로 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙인 SOLID 원칙부터 살펴보고자 한다.

## SRP ( 단일 책임의 원칙 )

먼저 SOLID 의 첫 글자인 S는, Single Responsibility Principle이다. 즉, 하나의 클래스는 하나의 책임만을 가져야한다는 원칙이다.
'너의 행동에 책임을 져라.' 라는 말이 있다. ~~이 말이 왜 나와...??~~
소프트웨어에서의 행위자는 **Actor**다.
즉 우리는 Actor의 행동이 정말 Actor의 책임인지 파악하고, 책임을 분리하여야 한다.

### 책임을 분리하자

어떤 사람이 ATM기계에서 만원을 인출하는 상황을 코드로 작성해보자.

``` swift
person.withdrawal(atm, amount: 10000)
```

인출의 행동의 주체가 person이기 때문에 위와 같은 코드가 순간적으로 그렇구나~ 라고 생각할 수 있다.
하지만 더 논리적으로 볼 필요가 있다. 인출의 책임이 과연 사람에게 있는 것인가?
만약 위의 인출함수를 작성한다면 ~~어떻게 짜야하지...~~ 어떤 카드로 인출할 것 인지, 인출한 돈을 어떻게 할 것인지 함수 내부에서 결정해야한다. 즉 사람에게 책임을 너무 많이 주었다고 볼 수 있다.

생각해보면 사람은 ATM에 카드를 넣고 인출을 요청하고, ATM이 은행 서버와 통신하여 돈을 인출해주는 것이다.
즉 인출의 책임은 ATM에게 있다는 것을 알 수 있으며, 간단하게 코드로 작성해보면 아래와 같다.

``` swift
let card = // get a card to withdrawal
atm.withdrawal(card, 10000) { money in
	// how to deal
}
```
우리는 사물의 행동을 생각하는 것이 어색할 수 있다. 하지만 단일 책임의 원칙을 곱씹어보면서, 하나의 Actor에 하나의 책임을 주는 연습을 해야한다.

### 책임을 단순화하자

사실 ATM은 출금뿐만 아니라 입금, 통장정리, 잔액조회, 현금서비스 등 여러가지 기능을 지원해야한다.
책임이 많아보이지 않는가? 그렇다면 ATM의 책임을 단순하게 해보자.

* 다양한 요청을 은행서버에 보낸다.
* 서버에서 받아온 응답값으로 그에 맞는 행동을 한다.

``` swift
let bankRequest = BankRequest(type: .withdrawal(card, 10000))
atm.request(bankRequest) { response
	// to do something
}
```

위 코드를 보면 ATM의 책임이 명확히 보이게 된다. 현재 예를 든 코드에서도 아직 많은 역할들이(카드에 대한 인증, 출력 등) 분리되어야하지만 이 글에선 여기까지 하도록 하겠다. ~~귀찮다~~

### 책임을 적당히 분리하자

'적당히?' 라고 생각할 수 있다.
책임을 분리하여 하나의 Actor가 하나의 책임만 갖도록 하라고 했지, 무작정 책임 작게 쪼개어 분리시키는 것이 좋은 것만은 아니다. 실제 개발시에는 분리를 어디까지 하느냐하는 판단도 중요하다. ATM을 구성하는 MOSFET(반도체 소자)의 책임까지 고려할 것은 아니지 않은가?

그렇다면 우리는 어느 단계까지 책임을 쪼개는 것이 맞을까?

`프로그래밍 변경이 필요한 책임의 최소 단위까지`

만약 더 쪼갠다면, 예를들어 A라는 책임을 a, b, c의 부분 책임으로 열심히 나누었는데 A라는 책임을 변경해야한다면 3개의 클래스를 변경해야하는 상황이 발생한다. 사실 이 판단은 경험과 통찰력 및 예지력이 필요하지만, 단일 책임 원칙을 지키면서 작성하려고 노력하다보면 판단력의 수준은 계속해서 높아질 것이다.

## OCP ( 개방 - 폐쇄 원칙 )

Open-Closed Principal은, 소프트웨어 개체들이 확장에는 열려있고 변경에는 닫혀있도록 하는 원칙이다. 즉 프로그램을 변경하기위해서 구현 로직을 수정하는 것이 아닌, 추가하는 방식으로 변경이 가능하도록 하게 하는 것이다.

### 추상화를 하자

OCP 원칙을 지키기 위해서는 추상화가 핵심요소이다.
다음과 같은 로그 출력 클래스가 있다고 가정해보자.

``` swift

class Log {
	static func info(_ message: String) {
		print("INFO. " + message)
	}
	static func warn(_ message: String) {
		print("WARNING. " + message)
	}
}

Log.info("안녕하세요")   // INFO. 안녕하세요
Log.warn("안녕하세요") // WARNING. 안녕하세요
```

만약 위의 코드에서, 한가지 로그 타입을 추가하고 싶다면 어떻게 해야할까?
`Log`라는 클래스를 **변경하여야** 한다. 위에서 설명했듯이, OCP 원칙을 지키기 위해서는 `Log`를 수정하지 않고 내부 구현이 다르게 처리될 수 있어야한다.
아래는 `PrinterType` 이라는 프로토콜을 생성하여 위에서 필요한 구현을 추상화 한 코드이다.

``` swift
protocol PrinterType {
	func print(_ message: String)
}

struct InformationPrinter: PrinterType {
	func print(_ message: String) {
		print("INFO. " + message)
	}
}

struct WarningPrinter: PrinterType {
	func print(_ message: String) {
		print("WARNING. " + message)
	}
}

class Log {
	static func log(_ String, printer: PrinterType) {
		printer.print(message)
	}
}

Log.log("안녕하세요", printer=InformationPrinter())
Log.log("안녕하세요", printer=WarningPrinter())

```
위와 같은 코드는, 로그 타입이 추가되더라도 `Log`의 코드 변경은 필요없다.
즉 프로토콜(규약)을 사용해서, 내부 로직을 외부에서 작성하여 넣어주는 것이 가능해졌다. 이것이 바로 OCP 원칙이다.

### 체크포인트
아래는 내가 생각해 본 OCP 원칙을 지키기 위한 코드리뷰 스텝이다.

* 코드에서 추후 변경 가능성이 있거나 기능이 추가될 수 있는 부분을 찾는다.
* 찾은 부분을 책임별로(SRP) 분리하여 인터페이스로 추상화 한다.
* 추상화 한 인터페이스를 주입받은 구현체를 작성한다.
* 구현체를 대입 / 사용하여 기존 로직이 돌아가게 한다.
* 일반적인 구현체를 작성하여 default 로 설정한다.

마지막에 언급한 `'일반적인 구현체를 작성하여 default 로 설정한다.'`는, OCP와는 관계가 없지만 아래와 같이 불필요한 코드를 제거할 수 있는 테크닉이다.

``` swift 
class Log {
	static var `default` = InformationPrinter()
	static func log(_ String, printer: PrinterType = Log.default) {
		printer.print(message)
	}
}

Log.log("안녕하세요") // INFO. 안녕하세요
Log.log("반갑습니다") // INFO. 반갑습니다
Log.log("경고입니다",  printer=WarningPrinter()) // WARNING: : 경고입니다

```

### 바꾼김에 하나만 더
현재 `PrinterType.print`의 인자는 `String` 값만 넘길 수 있다. 만약 `Int`를 넘기고 싶다면 어떻게 할까?
``` swift
protocol PrintType {
	func print(_ message: String)
	func print(_ message: Int)
}
```
위에 작성한 코드를 보니 OCP 원칙을 안지킨 것 같다는 느낌이 드는가?
그렇다면 잘 이해하며 따라오고 있다는 것 이다.

위의 코드는 타입마다 함수를 하나씩 추가해서 작성해야하는 엄청난 번거로움이 있다.
모든 타입의 출력물을 `String`으로 통일하기 위한 추상화를 해보자.

``` swift
protocol Printable {
	var description: String { get }
}

extension String: Printable {
	var description {
		get { return self }
	}
}

extension Int: Printable {
	var description {
		get { return String(self) }
	}
}

class Log {
	static func log(_ message: Printable, printer: PrinterType = Log.default) {
		printer.print(message.description)
	}
}
```
위와 같이 `Printable` 프로토콜을 생성하여, 각 객체 타입마다 `extension` 을 사용하여 확장 지향적인 코드를 작성할 수 있다. 사실 대부분 눈치챘겠지만, Printable 프로토콜은 이미 `Foundation` Framework 에 포함되어 있다. Apple도 여러가지 타입을 Printable 프로토콜을 이용해 String으로 변환하여 출력할 수 있게 OCP 원칙을 잘 지켰다고 볼 수 있다.

## LSP ( 리스코프 치환 원칙 )
## ISP ( 인터페이스 분리 원칙 )
## DIP ( 의존관계 역전 원칙 )