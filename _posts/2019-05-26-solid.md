---
title: 'SOLID ( 객체지향 설계원칙 )'
layout: post
tags:
  - SOLID
  - SRP
category: null
---
> 이 글은 개발하면서 궁금한 점들을 찾아보면서 내가 이해한 것을 내가 이해하기 쉽게 적은 글 이므로, 비판적인 시각으로 봐주시면 감사하겠습니다.

# SOLID ( 객체 지향 설계 )

'프로그래밍을 할 때 가장 중요한 것이 무엇인가요?' 라고 물어본다면, 2019년 5월 27일의 나로서는 아래와 같이 답할 것
이다.

`"유지보수가 쉽고 확장성 있게 짜는거요."`

유지보수가 쉽다는 말은 풀어서 아래를 충족하면 된다고 생각한다. ~~말은 쉽지~~

* 시간이 지나도 이해가 잘 된다.
* 요구사항이 변경/추가될 때 짜증이 안난다.

물론 더 여러가지가 있겠지만 위의 범주안에 어느정도 포함 될 것이고, 위를 만족한다면 어느정도 설계를 잘 했다고 파악된다.

그렇다면 위를 만족시키려면 어떻게 해야할까?
여러가지 지침들이 있지만, 2000대 초반에 나온 개념으로 객체 지향 프로그래밍 및 설계의 다섯 가지 기본 원칙인 SOLID 원칙부터 살펴보고자 한다.

## SRP ( 단일 책임의 원칙 )

먼저 SOLID 의 첫 글자인 S는, Single Responsibility Principle이다. 즉, 하나의 클래스는 하나의 책임만을 가져야한다는 원칙이다.
'너의 행동에 책임을 져라.' 라는 말이 있다. ~~이 말이 왜 나와...??~~
소프트웨어에서의 행위자는 **Actor**다.

즉 우리는 Actor의 행동이 정말 Actor의 책임인지 파악하고, 책임을 분리하여야 한다.

### 책임을 분리하자

어떤 사람이 ATM기계에서 만원을 인출하는 상황을 코드로 작성해보자.

``` swift
person.withdrawal(atm, amount: 10000)
```

인출의 행동의 주체가 person이기 때문에 위와 같은 코드가 순간적으로 그렇구나~ 라고 생각할 수 있다.
하지만 더 논리적으로 볼 필요가 있다. 인출의 책임이 과연 사람에게 있는 것인가?
만약 위의 인출함수를 작성한다면 ~~어떻게 짜야하지...~~ 어떤 카드로 인출할 것 인지, 인출한 돈을 어떻게 할 것인지 함수 내부에서 결정해야한다. 즉 사람에게 책임을 너무 많이 주었다고 볼 수 있다.


생각해보면 사람은 ATM에 카드를 넣고 인출을 요청하고, ATM이 은행 서버와 통신하여 돈을 인출해주는 것이다.
즉 인출의 책임은 ATM에게 있다는 것을 알 수 있으며, 간단하게 코드로 작성해보면 아래와 같다.

``` swift
let card = // get a card to withdrawal
atm.withdrawal(card, 10000) { money in
    // how to deal
}
```

우리는 사물의 행동을 생각하는 것이 어색할 수 있다. 하지만 단일 책임의 원칙을 곱씹어보면서, 하나의 Actor에 하나의 책임을 주는 연습을 해야한다.

### 책임을 단순화하자

사실 ATM은 출금뿐만 아니라 입금, 통장정리, 잔액조회, 현금서비스 등 여러가지 기능을 지원해야한다.
책임이 많아보이지 않는가? 그렇다면 ATM의 책임을 단순하게 해보자.
* 다양한 요청을 은행서버에 보낸다.
* 서버에서 받아온 응답값으로 그에 맞는 행동을 한다.

``` swift
let bankRequest = BankRequest(type: .withdrawal(card, 10000))
atm.request(bankRequest) { response
    // to do something
}
```
위 코드를 보면 ATM의 책임이 명확히 보이게 된다. 현재 예를 든 코드에서도 아직 많은 역할들이(카드에 대한 인증, 출력 
등) 분리되어야하지만 이 글에선 여기까지 하도록 하겠다. ~~귀찮다~~

### 책임을 적당히 분리하자

'적당히?' 라고 생각할 수 있다.
책임을 분리하여 하나의 Actor가 하나의 책임만 갖도록 하라고 했지, 무작정 책임 작게 쪼개어 분리시키는 것이 좋은 것만은 아니다. 실제 개발시에는 분리를 어디까지 하느냐하는 판단도 중요하다. ATM을 구성하는 MOSFET(반도체 소자)의 책임까지 고려할 것은 아니지 않은가?
그렇다면 우리는 어느 단계까지 책임을 쪼개는 것이 맞을까?

`프로그래밍 변경이 필요한 책임의 최소 단위까지`

만약 더 쪼갠다면, 예를들어 A라는 책임을 a, b, c의 부분 책임으로 열심히 나누었는데 A라는 책임을 변경해야한다면 3개의 클래스를 변경해야하는 상황이 발생한다. 사실 이 판단은 경험과 통찰력 및 예지력이 필요하지만, 단일 책임 원칙을 지키면서 작성하려고 노력하다보면 판단력의 수준은 계속해서 높아질 것이다.

## OCP ( 개방 - 폐쇄 원칙 )

개방 - 폐쇄 원칙은, 소프트웨어 개체들이 확장에는 열려있고 변경에는 닫혀있도록 하는 것이 핵심이다. 즉 프로그램을 변경하기위해서 구현 로직을 수정하는 것이 아닌, 추가하는 방식으로 변경이 가능하도록 하게 하는 것이다.

### 추상화를 하자

OCP 원칙을 지키기 위해서는 추상화가 핵심요소이다.
다음과 같은 로그 출력 클래스가 있다고 가정해보자.

``` swift
class Log {
    static func info(_ message: String) {
        print("INFO. " + message)
    }
    static func warn(_ message: String) {
        print("WARNING. " + message)
    }
}
Log.info("안녕하세요")   // INFO. 안녕하세요
Log.warn("안녕하세요") // WARNING. 안녕하세요
```

만약 위의 코드에서, 한가지 로그 타입을 추가하고 싶다면 어떻게 해야할까?
`Log`라는 클래스를 **변경하여야** 한다. 위에서 설명했듯이, OCP 원칙을 지키기 위해서는 `Log`를 수정하지 않고 내부 구현이 다르게 처리될 수 있어야한다.

아래는 `PrinterType` 이라는 프로토콜을 생성하여 위에서 필요한 구현을 추상화 한 코드이다.

``` swift
protocol PrinterType {
    func print(_ message: String)
}
struct InformationPrinter: PrinterType {
    func print(_ message: String) {
        print("INFO. " + message)
    }
}
struct WarningPrinter: PrinterType {
    func print(_ message: String) {
        print("WARNING. " + message)
    }
}
class Log {
    static func log(_ String, printer: PrinterType) {
        printer.print(message)
    }
}
Log.log("안녕하세요", printer=InformationPrinter())
Log.log("안녕하세요", printer=WarningPrinter())
```

위와 같은 코드는, 로그 타입이 추가되더라도 `Log`의 코드 변경은 필요없다.
즉 프로토콜(규약)을 사용해서, 내부 로직을 외부에서 작성하여 넣어주는 것이 가능해졌고 이것이 바로 OCP 원칙이다.

###  체크포인트

아래는 내가 생각해 본 OCP 원칙을 지키기 위한 코드리뷰 스텝이다.

* 코드에서 추후 변경 가능성이 있거나 기능이 추가될 수 있는 부분을 찾는다.
* 찾은 부분을 책임별로(SRP) 분리하여 인터페이스로 추상화 한다.
* 추상화 한 인터페이스를 주입받은 구현체를 작성한다.
* 구현체를 대입 / 사용하여 기존 로직이 돌아가게 한다.

## LSP ( 리스코프 치환 원칙 )

이름은 화려하지만 생각보다는 간단한 원칙이다. 내가 이해한바로는 아래와 같이 짧게 설명할 수 있다.

`기반클래스를 위해 작성한 테스트케이스가 하위클래스에도 적용되어야 한다.`

### 호환성이 있도록

조금 더 큰 범위에서 보자면, 우리가 개발할때 여러가지의 프레임워크 / 라이브러리를 사용하게 되는데, 계속해서 업데이트 되는 프레임워크와 라이브러리에 대응하는 시간이 많아진다면, 우리는 피로해지고 심지어는 그것들을 사용을 제거할지도 모른다. 즉 위에 적은 한 문장과 같은말로 해당 상황을 설명해보자면,

`하위 버전에 작성한 코드가 상위 버전에서도 사용가능하여야 한다.`

라는 말이 된다. 약간 더 감이 오지 않는가?

실제로 자바의 개발 프레임워크인 JDK와, HTTP는 위의 원칙을 잘 지켜왔기때문에 오랫동안 개발자들에게 사랑받아올 수 있었다고 생각한다. ~~망한 예로는 Internet Explorer...~~

### 포함 관계가 아닌 역할 관계의 IS-A

결국 이 원칙은 서브 클래스가 기반 클래스를 완벽하게 대체할 수 있도록 작성하여야 한다는 원칙이다.
OCP에서도 이야기 하였지만, 프로그램은 확장에 열려있어야한다고 했다. 따라서 올바른 확장을 하는것이 매우 중요하다.

확장의 방법에는 당연 서브 클래스도 포함이 되는데, 이때 기반 클래스와 클라이언트간의 규약(인터페이스)를 서브 클래스가 지키지 못한다면 이는 잘못된 확장을 하고있는 것이다.

우리는 기초 개념책에서 흔히 상속을 IS-A 관계로 정의하도록 한다.
이것을 보고 대부분 동물이라는 클래스를 만들고,

`강아지와 고양이 IS-A 동물`

을 만족하기 때문에 상속을 하려한다.

``` swift
class Animal {
    
}
class Dog: Animal {
    
}
class Cat: Animal {
    
}
```

하지만 위 클래스에서 우리는 동물을 어떻게 추상화하여 클라이언트에게 인터페이스를 제공할 수 있을까?
동물은 식물과 비교되는 개념으로 스스로 움직일 수 있는 모든 것을 지칭한다.
갑자기 생각난 절지동물인 지네와 돌고래는 과연 얼마나 동물이 제공하는 인터페이스를 잘 대체할 수 있을까?
만약 클라이언트가 정말 먹고, 자고, 싸는 정도의 인터페이스만을 제공하는 객체로 만족(대부분을 사용)한다면 그때는 `Animal`로 기반 클래스를 잡아도 될 것이다. 하지만 `Animal`을 상속받은 대부분의 객체를 사용하는 클라이언트는 서브 클래스가 제공하는 인터페이스에 의존할 가능성이 커보인다.

즉, 우리는 서브 클래스에 대해서 잘 몰라도 사용할 수 있도록 포함의 관계가 보다는 역할의 관계의 IS-A를 생각하여 기반 클래스를 작성해야한다.

## ISP ( 인터페이스 분리 원칙 )

인터페이스 분리 원칙은 클라이언트가 자신이 사용하지 않는 메소드에 의존하도록 강제되어서는 안된다는 것이 핵심이다.
즉 인터페이스는 그 인터페이스를 사용하는 클라이언트를 기준으로 분리해야 한다는 것이다.

### ISP vs SRP

ISP는 SRP와 다르게 하나의 클래스가 여러 책임 혹은 역할을 가지는 것을 인정한다.
사실 책임의 수준을 어느 단계에서 바라볼 것이냐에 따라 여러 책임이 될 수도 있고, 하나의 책임이 될 수도 있다.
아래는 실제 내가 Alamofire에 OAuth2 인증 기능을 넣으면서 작성했던 클래스이다.
``` swift
class OAuth2Handler: RequestAdapter, RequestRetrier  {
}
```


* `RequestAdapter` : `URLRequest` 생성의 마지막 단계에서, 적절히 수정하는 역할
* `RequestRetrier` : `URLRequest` 요청을 실패했을 때, 재시도를 처리하는 역할

위의 코드를 보면, `OAuth2Handler`는 Alamofire의 `URLRequest`에 인증 헤더를 넣어주는 역할과, 권한 없음 (401) 응답을 받았을 때, 인증토큰을 새로 발급받아 재시도하는 역할을 하는 클래스이다.

`API의 인증을 책임진다.` 라는 관점에서 봤을때는 하나의 역할을 가지고 있다고 할 수 있지만, Alamofire의 `RequestAdapter`와 `RequestRetrier`의 역할을 수행한다고 봤을 때에는 여러가지의 역할을 수행하고 있다고 볼 수 있다.

즉 여러가지의 역할을 갖는다고 해서, 잘못되었다는 것이 아니다.
대신 각각의 역할을 분리하여 여러개의 인터페이스로 추상화하는 것이 ISP이고, 위 예제에서는 이것들을 주입받아 처리하게 작성해놓았으므로 OCP도 잘 지켜서 작성되었다고 할 수 있다. ~~역시 Alamofire~~
ISP와 SRP의 차이점을 정리해보자면 아래와 같이 정리할 수 있을 것 같다.

`책임/역할을 클래스 단위로 구분했다면 SRP, 인터페이스 단위로 구분했다면 ISP 이다.`

### Protocol Oriented Programming

'객체 지향 하다가 왠 프로토콜 지향?' 라고 생각할 수 있지만, Swift 개발자라면 한번쯤은 들어봤을 것이라고 생각한다.
상속을 **수직 확장**이라고 한다면, 인터페이스에 구현을 더해 **수평 확장**을 하도록 하는 것이 POP인 것이다. 수직 확장을 하기위해서는 위에 설명한 LSP를 잘 지켜야하는데, 방대한 프로젝트에서 그것을 잘 지키기는 쉽지 않기 때문이다. 아무튼 추후 POP에 대해서는 다음에 자세하게 다뤄보도록 하겠다.
## DIP ( 의존관계 역전 원칙 )

이제 솔리드의 마지막 원칙 ~~순서가 있는 것은 아니다.~~인 DIP를 알아보자. 의존관계 역전 원칙은 기존의 구조지향 프로그래밍에서 통제권을 역전(IOC, Inversion of control) 시키는 것이 핵심이다.

### Framework vs Library

처음 프로그래밍을 배울때에 이 두가지의 차이점이 너무 어렵게 느껴졌던 때가 있었다. 지금 나한테 설명하라고 한다면, 아래와 같이 설명할 것 같다.

`내가 작성한 코드를 호출하는 것이 Framework, 내가 작성한 코드에서 호출한다면 Library이다.`

과거 구조(절차)지향 프로그래밍은 main() 함수에서 시작하여 모든 Actor의 행동을 통제권을 가지고 있었다. 하지만 객체지향 프로그래밍에서 즐겨 이용하는 Framework 사용방법은 이와 다르게 프로그램이 시작할 때 내가 생성한 객체들을 Framework에 등록해두고, Framework에서 이벤트를 발생시키면 객체들이 역할을 수행하는 구조이다.

즉 IOC는, 주 통제권이 main() `Actor`에서 Framework로 역전되었음을 의미한다. 여기서 역전은 통제권 뿐만 아니라, 인터페이스의 소유도 의미한다. 따라서 Framework는 인터페이스를 제공하고, 우리는 Framework에서 제공하는 인터페이스를 구현한 구현체를 Framework에 등록시켜 프로그램이 돌아가도록 만든다.

``` swift
class MainViewController: UIViewController {
    override func viewDidLoad() {
        super.viewDidLoad()
    }
}
```

대표적으로 위 코드는 DIP를 지킨 코드라고 할 수 있다. 애플에서 제공하는 `UIKit` Framework에서 UIViewController라는 **미리 정의된 인터페이스**를 제공하고 그에 맞는 구현을 하기만 하면 iOS 폰 화면에 MainViewController를 띄울 수 있다.

### DIP vs OCP

여기서 '미리 정의된 인터페이스'를 Hook 메소드라고 부르며 이는 역전을 위한 매개 포인트가 된다.
위 예에서는 `UIViewController`의 LifeCycle 함수들을 모두 Hook 메소드라고 할 수 있고, 구현을 함으로써 기능을 확장할 수 있다. 확장을 통해 `UIViewController`를 변경시키지 않고 기능을 바꿀 수 있다...
OCP에서 다룬 내용과 비슷하지 않나? 그렇다. 확장을 통한 기능 변경 관점에서 보았을 때 DIP와 OCP는 동일하다.

하지만 DIP의 핵심은 IOC라고 했던 것 처럼, 통제권의 주체가 역전되었다는 것이 OCP와의 다른점이다. 이렇듯, 객체 지향 설계원칙은 이렇게 서로가 서로를 이용하기도 하며 포함하기도 하는 특징이 있다.

### 구현체는 알 필요 없이

위 예에서 `UIKit` Framework는 `MainViewController`에 대해서 아무것도 모른다.
당연히 그래야할 것이다. 만약 내 코드에 `UIKit`이 의존한다면, 나는 `UIViewController`의 확장을 위해 애플의 UIKit 개발자에게 수정 요청 메일을 보내야 할지도 모른다.
즉 상위 모듈은 하위 모듈에 의존하면 안되며, 하위모듈 통제에 대한 부분은 인터페이스로 제공을 하여야한다.

## 마치며

객체지향 프로그래밍에 대해서는 정말 많이 듣기도 했고 학부때 시험 공부로도 해보았지만, '실제 설계에 어떻게 녹여내면 좋을까?' 라는 생각을 자주 했었다. '이렇게 설계하면 되겠지? 많이 보았던 패턴이니까.' 라는 마음으로 설계를 해왔었던 것 같은데, 이제는 내가 작성한 것이 어느 원칙을 잘 지켰고 못 지켰는지를 조금이나마 이론적으로 분석할 수 있게된 것 같다. 하지만 객체지향 설계에 대한 원칙일 뿐, 모든 것은 하나를 얻으면 하나를 잃게되는 Trade-Off 관계에 있다. 다만 내가 원칙을 지키지 않았을 때에는 그에 합당한 이유가 있어야 할 것이다. 

나중에 내가 이 글을 보았을 때, 부끄러워질 수 있도록 더 깊게 알 수 있었으면 좋겠고 이 글을 보는 개발자들에게 조금이나마 참고가 되었으면 좋겠다.
