---
category: null
layout: post
tags:
  - TDD
  - DI
title: 'TDD (테스트 주도 개발)'
---
> 작성중인 글 입니다.
> 디프만 발표 2019-11-30

# 테스트 주도 개발 (TDD)
테스트 주도 개발을 처음 들었던게 2년전 인 것 같은데, 크게 관심을 가지고 있지 않다가 [Let'Swift](http://letswift.kr/2018/ "2018 Let'Swift") 에서 전수열님의 TDD 세션을 보고 흥미를 가지게 되어 열심히 공부했고, 뜻밖에 의존성 주입과 좋은 설계를 같이 배울 수 있었다. 이 글은 내가 찾아보고 내 생각대로 정리한 글이다.

#### - 2019-11-30 추가


TDD를 공부하고 프로젝트에 적용하고 있던 중, 디프만 ([https://www.depromeet.com/](https://www.depromeet.com/ "https://www.depromeet.com/")) 에서 발표할 수 있는 기회를 얻게되었다. 사내 세미나에서는 몇 번 발표를 했었지만 첫 외부 세미나고 아직 TDD 입문단계였기 때문에 살짝 긴장이 되었지만, 여러가지 질문과 답변이 오가면서 나에게도 TDD를 실무에 적용하는데 있어서 생각을 정리할 수 있는 좋은 경험이 되었다고 생각한다.

![디프만 7기 발표 세션 TIMELINE](https://user-images.githubusercontent.com/19903689/72657379-ec6c4000-39e6-11ea-90ee-83f990642125.jpeg "디프만 7기 발표 세션 TIMELINE")
![TDD 발표](https://user-images.githubusercontent.com/19903689/73589568-3262f100-451b-11ea-82fb-7bc59b66f7ef.jpeg "TDD 발표")

## 1. 좋은 설계
TDD에서 왜 갑자기 좋은 설계? 라고 생각할 수 있지만 아래와 같은 띵언이 있다.

```테스트하기 좋다고 좋은 설계는 아니지만, 좋은 설계는 테스트하기 쉽다.```

좋은 설계란 모듈 또는 객체간 응집성이 높고 결합도가 낮도록 설계하는 것이다.
저번 글에서도 작성했었지만, [SOLID 원칙](https://kimjg.github.io/solid/) 을 잘 따른다면 꽤나 좋은 설계를 할 수 있다.

만약 어떤 한 객체가 다른 객체와의 결합도가 높다면 해당 객체를 테스트하기 매우 까다로워질 수 있다. 또한, 네트워크 의존성을 가지고 있는 객체라면 네트워크 상황에 따라 해당 객체를 테스트 가능 유무가 달라질 수 있다. 이 때문에 TDD를 하기위해서는 먼저 객체간의 의존성을 분리하여, 의존성을 주입(Dependency Injection, DI)하는 형태로 변경하여야 한다.

## 2. 의존성 주입 (DI)
일단 의존성 주입이 왜 필요한가에 대해서는 위에서 잠깐 언급을 했다. 그렇기 때문에 먼저 용어에 대한 설명을 먼저 할 필요가 있어보인다.

### 의존성
객체간의 의존성이란, 어떤 객체가 또 다른 객체를 내부에서 생성하여 사용하는 것으로 이해하면 된다.

``` swift
class AClass {
	func do() {
	}
}
class BClass {
	var aClass: AClass = AClass()
}
```

위 코드를 보면, BClass 내부에서 do라는 함수를 사용하기 위해 AClass를 생성하고 있는 모습을 볼 수 있다.
이렇게 되면, AClass의 변화에 BClass를 수정하지 않는 이상 영향을 그대로 받게될 뿐만아니라 BClass에서 사용하는 AClass의 통제권을 BClass에게 전부 주게된다. 이렇게 의존성이 강하게 코드를 작성하게 되면 변경에 매우 민감한 코드가 될 수밖에없다.

### 주입을 하자

``` swift
class AClass {
	func do() {
		// implementation
	}
}
class BClass {
	var aClass: AClass
	init(aClass: AClass) {
		this.aClass =  aClass
	}
}

let a = AClass()
let b = BClass(aClass: a)
```

위 코드는  AClass를 BClass에 주입하는 코드이다. 하지만 이렇게 의존성을 주입한다고해서 코드가 깔끔해지고 변경에 유연한 코드가 될 수 있을까? 중요한 한가지를 빼먹었다. 바로 의존성 분리이다.

## 3. 의존성 분리

의존성을 분리한다? 정확히 말하면 concrete 클래스, 즉 구현을 포함한 객체를 주입하는 것이 아니라 구현체의 인터페이스를 주입하라는 뜻이다. 사실 우리는 이미 이것에 대해서 [SOLID 원칙](https://kimjg.github.io/solid/)에서 배웠다. 요지는 살짝 다르지만, 의존 관계 역전 원칙(DIP)에서 다뤘었다. 즉 Concrete 클래스가 아닌, 인터페이스화하여 간접화된 의존성을 주입하게 되면 의존성을 분리할 수 있다.


``` swift
class AInterface {
    func do()
}
class AClass: AInterface {
	func do() {
		// implementation
	}
}
class BClass {
	var aInterface: AInterface
	init(aInterface: AInterface) {
		this.aInterface =  aInterface
	}
}

let a = AClass()
let b = BClass(aInterface: a)
```

위 코드는 의존성을 분리한 코드이다. 사실 여기까지는 [SOLID 원칙](https://kimjg.github.io/solid/)을 잘 이해한 사람이라면, 이렇게 의존성을 분리해서 코드를 작성했을 것이다. 특히 Network 의존성을 가지고 있는 객체라면, 반드시 위와 같이 의존성 분리를 해내야만 유닛테스트를 할 수 있다. 그렇다면 이것이 테스트 주도 개발을 할 때 어떠한 이점을 주는지 확인해보자.

## 4. 유닛 테스트

우리는 먼저 기존에 작성된 코드(legacy)에 의존성 분리를 했다. 그렇다면 유닛 테스트를 추가하면서 기존의 코드를 테스트 할 수 있다. 우리는 aInterface를 따르는 Test Double을 사용하여 (추후 설명 예정) B클래스의 동작을 테스트할 것이다. 여기서 중요한점은 각각의 클래스를 테스트하는 것을 목적으로 해야한다.

``` swift
class BClass {
	var aInterface: AInterface
	init(aInterface: AInterface) {
		this.aInterface =  aInterface
	}
	func usingAInterface(let parameter: String) -> String {
		let result = this.aInterface.do()
		return result + " with \(parameter)."
	}
}

let a = AClass()
let b = BClass(aClass: a)
```

우리는 B 클래스를 테스트하기전에, B클래스가 사용하는 A클래스부터 테스트를 완료하여야 한다. A클래스가 테스트되지 않았다면, B의 동작을 아무리 테스트하더라도 테스트의 안정성에 보장을 받을 수 없다.


``` swift
class AClass: AInterface {
	func do() -> String {
		return "Do A Class"
	}
}
```

만약 위와 같이 `"Do A Class"`라는 문자열을 반환하는 로직이 있다고 해보자.
우리는 위의 테스트를 아래와 같이 작성할 수 있다.

``` swift
func testA_do() -> String {
	let a: AInterface = AClass()
	XCTAssertTrue(a.do() == "Do A Class")
}
```

위 테스트 코드는 잘 동작할 것이다. 그렇다면 이제 우리는 BClass 를 테스트 할 수 있다.

``` swift
func testB_usingAInterface() -> String {
	let a: AInterface = AClass()
	let b: BClass = BClass(aInterface: a)
	XCTAssertTrue(b.usingAInterface(parameter: "B") == "Do A Class with B.")
}
```

이제 약간 감이 오는가? 우리가 밟은 절차를 정리해보자.

1. legacy 코드에는 `BClass`가 가지고 있는 `AClass`에 대한 강한 의존성이 존재했다.
2. `AClass`를 `BClass` 생성자 파라미터로 넣어주어 의존성 주입을 시켰다.
3. `AInterface`로 `AClass`를 간접화 시켜 의존성을 분리했다.
4. 테스트 된 `AClass`를 사용하는 `BClass`에 유닛테스트를 작성하였다.

이렇듯 기존에 객체간의 의존성이 강한(coupling) 부분을 모두 분리하는 작업이 선행되어야 유닛테스트를 작성할 수 있고 당연히 이런 구조가 되어있어야 TDD를 진행할 수 있다.

